<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Яблоко (Three.js)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; } /* Нейтральный фон */
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Инициализация сцены
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0); // Светло-серый/нейтральный фон

        // Инициализация камеры
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0.5, 3); // Камера смотрит на яблоко

        // Инициализация рендерера
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        renderer.shadowMap.enabled = true; // Включаем тени
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // --- Элементы освещения ---

        // Основной (направленный) свет для реалистичного освещения
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -5;
        directionalLight.shadow.camera.right = 5;
        directionalLight.shadow.camera.top = 5;
        directionalLight.shadow.camera.bottom = -5;
        scene.add(directionalLight);

        // Мягкий рассеянный свет (Ambient Light)
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambientLight);

        // --- Создание модели ЯБЛОКА ---
        
        // 1. Геометрия (попытка создать форму, похожую на яблоко)
        // Используем IcosahedronGeometry, затем деформируем её
        const appleGeometry = new THREE.SphereGeometry(1, 32, 32);
        
        // Небольшая деформация, чтобы сделать форму менее идеальной и добавить углубление сверху
        const positionAttribute = appleGeometry.getAttribute('position');
        const count = positionAttribute.count;

        for (let i = 0; i < count; i++) {
            const vector = new THREE.Vector3().fromBufferAttribute(positionAttribute, i);
            const radius = vector.length();
            
            // Немного сжимаем полюса (для углубления)
            if (vector.y > 0.9 * radius) {
                // Углубление сверху
                vector.multiplyScalar(1 - (vector.y - 0.9 * radius) * 0.5);
            } else if (vector.y < -0.9 * radius) {
                 // Небольшое углубление снизу
                vector.multiplyScalar(1 - (-0.9 * radius - vector.y) * 0.1);
            }
            
            // Рандомная небольшая деформация для неидеальности (как у настоящего яблока)
            const noise = (Math.random() - 0.5) * 0.05;
            vector.multiplyScalar(1 + noise);

            positionAttribute.setXYZ(i, vector.x, vector.y, vector.z);
        }
        appleGeometry.attributes.position.needsUpdate = true;
        appleGeometry.computeVertexNormals();


        // 2. Материал (высокое качество с глянцем)
        const appleColor = new THREE.Color(0xdc143c); // Насыщенный красный цвет (Crimson)

        const appleMaterial = new THREE.MeshPhysicalMaterial({
            color: appleColor,
            metalness: 0.1, // Немного металлического блеска (глянцевость)
            roughness: 0.3, // Не сильно глянцевый, но отражает свет
            clearcoat: 1.0, // Дополнительный слой лака/глянца
            clearcoatRoughness: 0.1,
            // Добавляем Subsurface Scattering для имитации полупрозрачности фрукта
            // (только для примера, для полной работы нужен более сложный шейдер)
            transparent: false,
        });

        const apple = new THREE.Mesh(appleGeometry, appleMaterial);
        apple.position.y = 0;
        apple.scale.set(1.5, 1.5, 1.5); // Увеличиваем размер
        apple.castShadow = true;
        apple.receiveShadow = true;
        scene.add(apple);

        // --- Добавление веточки (стебля) ---
        const stemGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
        const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 }); // Коричневый
        const stem = new THREE.Mesh(stemGeometry, stemMaterial);
        stem.position.set(0, 1.35, 0);
        stem.castShadow = true;
        stem.receiveShadow = true;
        scene.add(stem);


        // --- Поверхность (Плоскость) ---
        const planeGeometry = new THREE.PlaneGeometry(10, 10);
        const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc }); // Светло-серый
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2; // Поворот на 90 градусов, чтобы сделать его полом
        plane.position.y = -1.5;
        plane.receiveShadow = true;
        scene.add(plane);


        // --- Управление камерой (OrbitControls) ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0); // Фокус на центре сцены
        controls.enableDamping = true; // Плавное вращение
        controls.dampingFactor = 0.05;
        controls.minDistance = 2;
        controls.maxDistance = 10;
        controls.update();

        // --- Цикл анимации ---
        function animate() {
            requestAnimationFrame(animate);

            // Обновляем контролы для плавности
            controls.update();

            renderer.render(scene, camera);
        }

        animate();

        // Обработчик изменения размера окна
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);
    </script>
</body>
</html>
