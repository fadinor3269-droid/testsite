<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model of iPhone 17 Pro Max</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Neutral surface (gray plane)
        const planeGeometry = new THREE.PlaneGeometry(500, 500);
        const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, side: THREE.DoubleSide });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -50; // Slightly below the iPhone
        scene.add(plane);

        // Simple lighting from above
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(0, 200, 0);
        scene.add(directionalLight);

        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        // iPhone 17 Pro Max model group
        const iphoneGroup = new THREE.Group();

        // Dimensions in mm (scaled by 0.1 for better view, but keeping 1:1 for detail)
        const scale = 0.1; // Scale down for visibility in scene
        const width = 78 * scale;
        const height = 163.4 * scale;
        const depth = 8.75 * scale;
        const cornerRadius = 10 * scale; // Approximate corner radius

        // Body: Extruded rounded rectangle for the frame (aluminum)
        const bodyShape = new THREE.Shape();
        bodyShape.moveTo(cornerRadius, 0);
        bodyShape.lineTo(width - cornerRadius, 0);
        bodyShape.quadraticCurveTo(width, 0, width, cornerRadius);
        bodyShape.lineTo(width, height - cornerRadius);
        bodyShape.quadraticCurveTo(width, height, width - cornerRadius, height);
        bodyShape.lineTo(cornerRadius, height);
        bodyShape.quadraticCurveTo(0, height, 0, height - cornerRadius);
        bodyShape.lineTo(0, cornerRadius);
        bodyShape.quadraticCurveTo(0, 0, cornerRadius, 0);

        const extrudeSettings = {
            steps: 2,
            depth: depth,
            bevelEnabled: true,
            bevelThickness: 0.5 * scale,
            bevelSize: 0.5 * scale,
            bevelOffset: 0,
            bevelSegments: 5
        };

        const bodyGeometry = new THREE.ExtrudeGeometry(bodyShape, extrudeSettings);
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, metalness: 0.8, roughness: 0.2 }); // Silver aluminum
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        iphoneGroup.add(body);

        // Back glass (Ceramic Shield)
        const backGeometry = new THREE.PlaneGeometry(width - 2 * scale, height - 2 * scale);
        const backMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.1, metalness: 0 }); // Glossy white-ish
        const back = new THREE.Mesh(backGeometry, backMaterial);
        back.position.z = depth / 2 + 0.1 * scale; // Slightly raised
        back.rotation.y = Math.PI; // Face back
        iphoneGroup.add(back);

        // Front screen (OLED display)
        const screenWidth = width - 2 * scale; // Minimal bezel
        const screenHeight = height - 2 * scale;
        const screenGeometry = new THREE.PlaneGeometry(screenWidth, screenHeight, 32, 32);
        // Load a texture for the screen (any picture, e.g., a landscape)
        const textureLoader = new THREE.TextureLoader();
        const screenTexture = textureLoader.load('https://picsum.photos/800/1600'); // Random image as wallpaper
        const screenMaterial = new THREE.MeshBasicMaterial({ map: screenTexture });
        const screen = new THREE.Mesh(screenGeometry, screenMaterial);
        screen.position.z = -depth / 2 - 0.1 * scale; // Front side
        iphoneGroup.add(screen);

        // Dynamic Island (pill-shaped cutout for front camera)
        const islandWidth = 30 * scale;
        const islandHeight = 10 * scale;
        const islandShape = new THREE.Shape();
        islandShape.moveTo(0, 0);
        islandShape.absarc(islandWidth / 2, 0, islandHeight / 2, Math.PI / 2, 3 * Math.PI / 2, true);
        islandShape.absarc(-islandWidth / 2, 0, islandHeight / 2, 3 * Math.PI / 2, Math.PI / 2, true);
        const islandGeometry = new THREE.ExtrudeGeometry(islandShape, { depth: 0.1 * scale, bevelEnabled: false });
        const islandMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 }); // Black cutout
        const dynamicIsland = new THREE.Mesh(islandGeometry, islandMaterial);
        dynamicIsland.position.set(0, height / 2 - islandHeight - 5 * scale, -depth / 2 - 0.05 * scale); // Top center
        dynamicIsland.rotation.x = Math.PI / 2;
        iphoneGroup.add(dynamicIsland);

        // Front camera (small circle in Dynamic Island)
        const frontCameraRadius = 2 * scale;
        const frontCameraGeometry = new THREE.CircleGeometry(frontCameraRadius, 32);
        const frontCameraMaterial = new THREE.MeshStandardMaterial({ color: 0x000000, metalness: 0.5 });
        const frontCamera = new THREE.Mesh(frontCameraGeometry, frontCameraMaterial);
        frontCamera.position.set(islandWidth / 4, height / 2 - islandHeight - 5 * scale, -depth / 2 - 0.2 * scale);
        frontCamera.rotation.x = -Math.PI / 2;
        iphoneGroup.add(frontCamera);

        // Rear camera bump (square-ish, raised)
        const bumpSize = 40 * scale;
        const bumpHeight = 2 * scale;
        const bumpGeometry = new THREE.BoxGeometry(bumpSize, bumpSize, bumpHeight);
        const bumpMaterial = new THREE.MeshStandardMaterial({ color: 0xA9A9A9, metalness: 0.7 });
        const cameraBump = new THREE.Mesh(bumpGeometry, bumpMaterial);
        cameraBump.position.set(-width / 2 + bumpSize / 2 + 5 * scale, height / 2 - bumpSize / 2 - 5 * scale, depth / 2 + bumpHeight / 2);
        iphoneGroup.add(cameraBump);

        // Rear cameras: 3 lenses in triangle layout
        const lensRadius = 5 * scale;
        const lensMaterial = new THREE.MeshStandardMaterial({ color: 0x000000, metalness: 0.9, roughness: 0.1 });
        
        // Main camera
        const mainLens = new THREE.CylinderGeometry(lensRadius, lensRadius, 0.5 * scale, 32);
        const mainMesh = new THREE.Mesh(mainLens, lensMaterial);
        mainMesh.position.set(-width / 2 + bumpSize / 2 + 5 * scale - bumpSize / 3, height / 2 - bumpSize / 2 - 5 * scale + bumpSize / 3, depth / 2 + bumpHeight + 0.25 * scale);
        mainMesh.rotation.x = Math.PI / 2;
        iphoneGroup.add(mainMesh);

        // Ultra-wide
        const ultraLens = new THREE.CylinderGeometry(lensRadius, lensRadius, 0.5 * scale, 32);
        const ultraMesh = new THREE.Mesh(ultraLens, lensMaterial);
        ultraMesh.position.set(-width / 2 + bumpSize / 2 + 5 * scale + bumpSize / 3, height / 2 - bumpSize / 2 - 5 * scale + bumpSize / 3, depth / 2 + bumpHeight + 0.25 * scale);
        ultraMesh.rotation.x = Math.PI / 2;
        iphoneGroup.add(ultraMesh);

        // Telephoto
        const teleLens = new THREE.CylinderGeometry(lensRadius, lensRadius, 0.5 * scale, 32);
        const teleMesh = new THREE.Mesh(teleLens, lensMaterial);
        teleMesh.position.set(-width / 2 + bumpSize / 2 + 5 * scale, height / 2 - bumpSize / 2 - 5 * scale - bumpSize / 3, depth / 2 + bumpHeight + 0.25 * scale);
        teleMesh.rotation.x = Math.PI / 2;
        iphoneGroup.add(teleMesh);

        // Flash (small circle)
        const flashRadius = 3 * scale;
        const flashGeometry = new THREE.CircleGeometry(flashRadius, 32);
        const flashMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, emissive: 0xFFFFFF, emissiveIntensity: 0.2 });
        const flash = new THREE.Mesh(flashGeometry, flashMaterial);
        flash.position.set(-width / 2 + bumpSize / 2 + 5 * scale + bumpSize / 3, height / 2 - bumpSize / 2 - 5 * scale - bumpSize / 3, depth / 2 + bumpHeight + 0.1 * scale);
        flash.rotation.x = Math.PI / 2;
        iphoneGroup.add(flash);

        // LiDAR scanner (small dot)
        const lidarRadius = 2 * scale;
        const lidarGeometry = new THREE.CircleGeometry(lidarRadius, 32);
        const lidarMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const lidar = new THREE.Mesh(lidarGeometry, lidarMaterial);
        lidar.position.set(-width / 2 + bumpSize / 2 + 5 * scale - bumpSize / 3, height / 2 - bumpSize / 2 - 5 * scale - bumpSize / 3, depth / 2 + bumpHeight + 0.1 * scale);
        lidar.rotation.x = Math.PI / 2;
        iphoneGroup.add(lidar);

        // Side buttons (approximate)
        // Volume buttons on left
        const buttonWidth = 3 * scale;
        const buttonHeight = 10 * scale;
        const buttonDepth = 0.5 * scale;
        const volumeUpGeometry = new THREE.BoxGeometry(buttonWidth, buttonHeight, buttonDepth);
        const buttonMaterial = new THREE.MeshStandardMaterial({ color: 0xA9A9A9 });
        const volumeUp = new THREE.Mesh(volumeUpGeometry, buttonMaterial);
        volumeUp.position.set(-width / 2 - buttonDepth / 2, 30 * scale, 0);
        volumeUp.rotation.y = Math.PI / 2;
        iphoneGroup.add(volumeUp);

        const volumeDown = volumeUp.clone();
        volumeDown.position.y = 10 * scale;
        iphoneGroup.add(volumeDown);

        // Action button below volume
        const actionButton = volumeUp.clone();
        actionButton.position.y = -10 * scale;
        iphoneGroup.add(actionButton);

        // Power/Side button on right
        const powerButtonHeight = 30 * scale;
        const powerGeometry = new THREE.BoxGeometry(buttonWidth, powerButtonHeight, buttonDepth);
        const powerButton = new THREE.Mesh(powerGeometry, buttonMaterial);
        powerButton.position.set(width / 2 + buttonDepth / 2, 40 * scale, 0);
        powerButton.rotation.y = Math.PI / 2;
        iphoneGroup.add(powerButton);

        // Camera Control button below power? (assuming)
        const cameraControl = volumeUp.clone();
        cameraControl.position.set(width / 2 + buttonDepth / 2, 0, 0);
        cameraControl.rotation.y = Math.PI / 2;
        iphoneGroup.add(cameraControl);

        // USB-C port bottom
        const portWidth = 10 * scale;
        const portHeight = 3 * scale;
        const portGeometry = new THREE.BoxGeometry(portWidth, portHeight, 0.1 * scale);
        const portMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const usbPort = new THREE.Mesh(portGeometry, portMaterial);
        usbPort.position.set(0, -height / 2, 0);
        usbPort.rotation.z = Math.PI / 2;
        iphoneGroup.add(usbPort);

        // Add iPhone group to scene
        iphoneGroup.position.y = 0; // Above the plane
        iphoneGroup.rotation.y = 0; // Facing front
        scene.add(iphoneGroup);

        // Camera position (in front)
        camera.position.set(0, height / 2, 200 * scale);
        camera.lookAt(0, 0, 0);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            iphoneGroup.rotation.y += 0.001; // Slow rotation for view
            renderer.render(scene, camera);
        }
        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
